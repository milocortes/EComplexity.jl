var documenterSearchIndex = {"docs":
[{"location":"r_integration/#R-integration-with-[JuliaCall](https://cran.r-project.org/web/packages/JuliaCall/readme/README.html)","page":"R integration with JuliaCall","title":"R integration with JuliaCall","text":"","category":"section"},{"location":"r_integration/","page":"R integration with JuliaCall","title":"R integration with JuliaCall","text":"Package JuliaCall is an R interface to Julia. ","category":"page"},{"location":"r_integration/#Usage","page":"R integration with JuliaCall","title":"Usage","text":"","category":"section"},{"location":"r_integration/","page":"R integration with JuliaCall","title":"R integration with JuliaCall","text":"The next block of code shows the basic usage of JuliaCall and EComplexity.jl:","category":"page"},{"location":"r_integration/","page":"R integration with JuliaCall","title":"R integration with JuliaCall","text":"### Install JuliaCall\ninstall.packages(\"JuliaCall\")\n\n### Load JuliaCall package\nlibrary(JuliaCall)\n\n### Set the actual Julia binary path in your computer\noptions(JULIA_HOME=\"/home/milo/julia_bins/julia-1.9.3/bin/\")\n\n### Install EComplexity.jl\njulia_command('using Pkg ; Pkg.add(url = \"https://github.com/milocortes/EComplexity.jl.git\")')\n\n### Verify the installation\njulia_installed_package(\"EComplexity\")\n\n### Load dataset\ndf <- read.csv(\"https://raw.githubusercontent.com/milocortes/InvESt_complexity/main/datos/data_test_EComplexity_package/complex_data.csv\")\n\n### Load EComplexity.jl\njulia_library(\"EComplexity\")\n\n### Execute the function that calculates the complexity measures\ncdata <- julia_eval(\"complexity_metrics\")(df, \"export_value\", \"hs_product_code\", \"location_code\")","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#GitHub-installation","page":"Getting Started","title":"GitHub installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install EComplexity from GitHub, you must first have a working Julia installation on your computer. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once Julia is set up, start a Julia session and add the EComplexity package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n\npkg> add https://github.com/milocortes/EComplexity.jl.git","category":"page"},{"location":"getting_started/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Import packages\nusing EComplexity\nusing CSV\nusing DataFrames\n\nusing ZipFile\nimport Downloads\n\n### Import trade data from CID Atlas\ndata_url = \"https://intl-atlas-downloads.s3.amazonaws.com/\"\nfile_name = \"country_hsproduct2digit_year.csv.zip\"\n\n# Downloads the file in the current working directory\nDownloads.download(data_url*file_name, file_name)\n\n# Extracts data from a ZIP file\ntrade_data_CID_atlas_archive = ZipFile.Reader(file_name)\n\n# Load data from the descompressed zip file\ndata = CSV.read(read(trade_data_CID_atlas_archive.files[1]), DataFrame)\n\n# Select specific columns of the dataframe\ndata = data[:,[:year,:location_code,:hs_product_code,:export_value]]\n\n# Subset rows \ncomplex_data = data[data.year .==2010,:]\n\n# Define column names for location, product and value\nvalue_col_name = \"export_value\"\nactiviy_col_name = \"hs_product_code\"\nplace_col_name = \"location_code\"\n\n# Calculate complexity metrics\ncdata = complexity_metrics(complex_data, value_col_name, activiy_col_name, place_col_name)\n\n## Calculate proximity matrix\n# Compute RCA\npaises_RCA = RCA(complex_data, value_col_name, activiy_col_name, place_col_name)\n\n# Compute M matrix\nM_rca = build_Mcp(paises_RCA, activiy_col_name, place_col_name, 1.0)\n\n# Compute proximity\nproximity_mat = proximity(M_rca, activiy_col_name, place_col_name)\n","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"dede","category":"page"},{"location":"economic_complexity_theory/#Economic-Complexity","page":"Economic Complexity","title":"Economic Complexity","text":"","category":"section"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"The Economic Complexity Index (ECI) and the product complexity index (PCI) are metrics that infers information about countries’ productive capabilities from their export baskets.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"The ECI and PCI measures are calculated using an algorithm that operates on a binary country-product matrix M with elements M_cp=1 if country c has a revealed comparative advantage (RCA) > 1 in product p, where RCA is calculate using the Balassa index:","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"    beginequation\n        RCA_cp =dfracx(cp)sum_i x(cp) Bigg  dfracsum_c x(cp)sum_cp x(cp)\n    endequation","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"where x_cp is country c's exports of product p. RCA  measures whether a country c exports more of a product p, as a share of its total exports, than the \"average\" country (RCA1 not RCA1). ","category":"page"},{"location":"economic_complexity_theory/#[The-ECI-and-PCI-(Mealy,-P.,-Farmer,-J.-D.,-and-Teytelboym,-A.-2019)](https://www.science.org/doi/10.1126/sciadv.aau1705)","page":"Economic Complexity","title":"The ECI and PCI (Mealy, P., Farmer, J. D., & Teytelboym, A. 2019)","text":"","category":"section"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"The ECI and PCI were originally defined through an iterative, self-referential method of reflections algorithm that first calculates diversity and ubiquity and then recursively uses the information in one to correct the other. However, it can be shown (G. Caldarelli, et at, 2012)(M. Cristelli, et al, 2013) that the method of reflections is equivalent to finding the eigenvalues of a matrix tildeM whose rows and columns correspond to countries and whose entries are given by (in matrix notation)","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"    beginequation\n        tildeM = D^-1MU^-1M^\n    endequation    ","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"where D is the diagonal matrix formed from the vector of country diversity values and U is the diagonal matrix formed from the vector of product ubiquity values.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"When applied to country trade data, one can think of tildeM as a diversity-weighted (or normalized) similarity matrix, reflecting how similar two countries’ export baskets are.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"Further, from Eq. 2, we can see that","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"    beginequation\n        tildeM = D^-1S\n    endequation    ","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"where S = MU^-1M^ is a symmetric similarity matrix in which each element S_cc^ represents the products that country c has in common with country c^, weighted by the inverse of each product’s ubiquity.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"Since tildeM is a row-stochastic matrix (its rows sum to one), its entries can also be interpreted as conditional transition probabilities in a Markov transition matrix. The ECI is defined as the eigenvector associated with the second largest right eigenvalue of tildeM. This eigenvector determines a “diffusion distance” between the stationary probabilities of states reached by a random walk described by this Markov transition matrix.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"The PCI is symmetrically defined by transposing the country-product matrix M and finding the eigenvector corresponding to the second largest right eigenvalue of tildeM, given by","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"    beginequation\n        hatM = U^-1M^D^-1M\n    endequation    ","category":"page"},{"location":"economic_complexity_theory/#Proximity","page":"Economic Complexity","title":"Proximity","text":"","category":"section"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"Formally, the proximity phi between products i and j is the minimum of the pairwise conditional probabilities of a country exporting a good given that it exports another.","category":"page"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"    beginequation\n        phi_ij = min biglbrace P(RCAx_iRCAx_j)P(RCAx_jRCAx_i) bigrbrace \n    endequation    ","category":"page"},{"location":"economic_complexity_theory/#Distance","page":"Economic Complexity","title":"Distance","text":"","category":"section"},{"location":"economic_complexity_theory/","page":"Economic Complexity","title":"Economic Complexity","text":"beginequation\n    d_cp = dfracsum_p(1-M_cp) phi_ppsum_p phi_pp\nendequation","category":"page"},{"location":"#EComplexity.jl-:-Economic-Complexity-in-Julia","page":"Introduction","title":"EComplexity.jl : Economic Complexity in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EComplexity is a package to calculate economic complexity indices in Julia. The package is inspired by others implementations as py-ecomplexity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The EComplexity package is developed by the Laboratorio de Desarrollo Regional team at Escuela de Gobierno y Transformación Pública ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"getting_started.md\",\n    \"economic_complexity_theory.md\"\n    ]","category":"page"}]
}
